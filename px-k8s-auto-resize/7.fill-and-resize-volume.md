In this step, we will run a bigger benchmark and run out of space to show how easy it is to add space to a volume dynamically.

### Step: Open a shell inside the postgres container

Below commands exec into the postgres pod:

```
POD=`kubectl get pods -l app=postgres | grep Running | grep 1/1 | awk '{print $1}'`
kubectl exec -it $POD bash
```{{execute T1}}

Next we can launch the psql utility and create a database
```
psql
create database pxdemo;
\l
\q
```{{execute T1}}

Use pgbench to run a baseline transaction benchmark which will try to grow the volume to a size that is greater than thee 20% that we defined in our AutoPilot Rulee. This should trigger AutoPilot should resize the volume.

```
pgbench -i -s 50 pxdemo
```{{execute T1}}

* You will see a lot of error messages, if you look at the first one it will say "No space left on device". The pod is going to fail but that's ok, we'll let STORK reschedule it. If the pod doesn't faile you will have to ```exit```{{execute T1}} from the pod shell before proceeding.

### Step: Check to see if the rule was triggered

We can retrieve events by using the `kubectl get events` and filtering for the `AutoPilotRule` events that match our use case.

```
kubectl get events --field-selector involvedObject.kind=AutopilotRule,involvedObject.name=auto-volume-resize --all-namespaces
```{{execute T1}}

Inspect the volume and verify that it now has grown but 200% capacity (3GB).

```
kubectl get pvc px-postgres-pvc
```{{execute T1}}

As you can see the volume is now  expanded and our PostgresDB database didn't require restarting.
```
kubectl get pods
```{{execute T1}}